import csv
import os
from datetime import datetime
import path_loader as pl


class PressureSeries:
    """Loads and stores pressure time-series data for a specific sample.

    Reads pressure data from CSV files generated by PythonLogger.py, filtering
    by sample ID and an optional local datetime range.

    Attributes:
        sample_ID: Identifier for the sample (e.g., '37').
        csvs_path: Path to the directory containing pressure log CSV files.
        start_datetime_local: Start of the time range (local time, inclusive), or
            None to include all data from the beginning.
        end_datetime_local: End of the time range (local time, inclusive), or
            None to include all data to the present.
        pressure_data: List of (datetime, pressure) tuples within the time range.
    """

    def __init__(self, sample_ID: str, start_datetime_local: datetime = None, end_datetime_local: datetime = None) -> None:
        """Initialize PressureSeries by loading data for the given sample and time range.

        Args:
            sample_ID: Identifier for the sample (e.g., '37').
            start_datetime_local: Start of the time range (local time, inclusive).
                Defaults to None, which includes all data from the beginning.
            end_datetime_local: End of the time range (local time, inclusive).
                Defaults to None, which includes all data to the present.

        Raises:
            ValueError: If start_datetime_local is after end_datetime_local, or if
                no data is found for the sample in the specified time range.
        """
        self.sample_ID = sample_ID
        self.csvs_path = pl.pressure_logs_path
        if start_datetime_local is not None and end_datetime_local is not None:
            if start_datetime_local > end_datetime_local:
                raise ValueError('Start datetime must be before end datetime')
        self.start_datetime_local = start_datetime_local
        self.end_datetime_local = end_datetime_local
        self.pressure_data = self.load_pressure_data(start_datetime_local, end_datetime_local)

    def load_pressure_data(self, start_datetime_local: datetime = None, end_datetime_local: datetime = None) -> list:
        """Load pressure data from CSV files within the specified time range.

        Scans CSV files matching the sample ID, then filters individual data points
        to those within the specified datetime range. Filenames encode local time,
        and Unix timestamps in the CSV are converted to local time via fromtimestamp().

        Args:
            start_datetime_local: Start of the time range (local time, inclusive).
                Defaults to None, which includes all data from the beginning.
            end_datetime_local: End of the time range (local time, inclusive).
                Defaults to None, which includes all data to the present.

        Returns:
            List of (datetime, pressure) tuples, where datetime is in local time
            and pressure is in kPa (gage).

        Raises:
            ValueError: If no data is found for the sample in the specified time range.
        """
        # Use min/max datetime if not specified
        if start_datetime_local is None:
            start_datetime_local = datetime.min
        if end_datetime_local is None:
            end_datetime_local = datetime.max
        # filenames look like sample53_cellB_pressure_log_start2025-12-27_00-00-00.csv
        csvs_for_sample = []
        for file in os.listdir(self.csvs_path):
            # check file is csv and is for the correct sample
            if file.startswith('sample' + self.sample_ID) and file.endswith('.csv'):
                # extract datetime from filename: find 'start' and remove '.csv'
                start_idx = file.find('start') + len('start')
                file_datetime_str = file[start_idx:].replace('.csv', '')
                file_datetime = datetime.strptime(file_datetime_str, '%Y-%m-%d_%H-%M-%S')
                # check if file start is before the end datetime
                if file_datetime < end_datetime_local:
                    csvs_for_sample.append(file)
        pressure_time_data = []
        for csv_file in csvs_for_sample:
            with open(os.path.join(self.csvs_path, csv_file), 'r') as f:
                reader = csv.reader(f)
                next(reader)  # skip header
                for row in reader:
                    # fromtimestamp() converts unix timestamp to local time
                    timestamp = datetime.fromtimestamp(float(row[0]))
                    if timestamp < start_datetime_local or timestamp > end_datetime_local:
                        continue
                    pressure = float(row[1])
                    pressure_time_data.append((timestamp, pressure))
        # if empty, raise error
        if not pressure_time_data:
            start_str = start_datetime_local.strftime('%Y-%m-%d %H:%M:%S') if start_datetime_local != datetime.min else 'the beginning'
            end_str = end_datetime_local.strftime('%Y-%m-%d %H:%M:%S') if end_datetime_local != datetime.max else 'now'
            raise ValueError(f'No data found for sample {self.sample_ID} between {start_str} and {end_str}')
        return pressure_time_data


if __name__ == '__main__':
    sample_ID = '53'
    start_datetime_local = datetime.strptime('2026-01-03 18:00:00', '%Y-%m-%d %H:%M:%S')
    end_datetime_local = datetime.strptime('2026-01-08 19:59:59', '%Y-%m-%d %H:%M:%S')
    ps = PressureSeries(sample_ID, start_datetime_local, end_datetime_local)
    # plot data
    import matplotlib.pyplot as plt
    times, pressures = zip(*ps.pressure_data)
    print(f"Plotting {len(pressures)} data points")
    plt.plot(times, pressures)
    plt.xlabel('Time (local)')
    plt.ylabel('Pressure (kPa, gage)')
    plt.title(f'Pressure for Sample {sample_ID}')
    plt.show()